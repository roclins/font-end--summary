

### 第3章 基本概念

1.未定义的或未初始化的变量的数据类型为undefined , 

```
var a;
console.log(a)   //undefined  对于定义后但未初始化的变量，报undefined
========================================
console.log(a)   //报错
```

2.null表示一个空对象指针，其数据类型为 Object 

3.总共有6种数据类型 
  5基本数据类型：undefined，null，String，Number，Boolean

 1复杂数据类型：Object

 其余所有复杂数据类型都属于Object

4、

| 数据类型  | 转换为true | 转换为false     |
| --------- | ---------- | --------------- |
| Number    | 除0以外    | 0和NAN          |
| String    | 非空字符串 | “” （空字符串） |
| Boolean   | true       | false           |
| Object    | 任何对象   | null            |
| Undefined | 不适用     | undefined       |

5、isNAN = 是 非数字？  

	例如 isNAN（a）  a不是一个数字，则isNAN（a）= true
	
	但是isNAN会尝试将a转换为一个数字，如果a = “10”，isNAN（a）= false//a是一个数字
	
	isNAN（true）= false// true = 1

6、每个字符串都有一个toString（）方法，但是null和undefined没有，

	可以用转型函数String（）
	
	还可以用字符串+“” ，转换为字符串

7、函数不介意传递进来多少个参数，也不在乎传进来的参数类型，传进来的参数都会保存在

	arguments中（这是一个伪数组）

8、++a和a++的区别是：

	++a是先运算符在前，所以是先 自增，在进行其他运算，而a++，++在后，先做其他运算，在自增

9、parseInt:忽略字符串前面的空格，找到第一个非空字符，如果是第一个非空字符是数字，则继续解析第二个，直到找到不少非数字为止；如果第一个非空字符不是数字，则返回NaN. parseInt 可以指定字符串的进制，如果满足，也可以转换。(转换成整数)

```
var num1 = parseInt("1234blue")  //1234
var num2 = parseInt("22.3")       //22
var num3 = parseInt("22.3avc")    //22
var num4 = parseInt("ac123")     //NaN
var num5 = parseInt("AF")        //NaN
var num6 = parseInt("0xAF")     //175(16进制)
var num7 = parseInt("AF",16)    //175  
```

parseFloat（转换成小数）：第1个小数点是有效的，第2个是无效的；会忽略前置0；十六 进制都会转换成 0 

10、switch语句：本质上是判断 条件与 case 的value是否相等，而且是 === ，不会转换，例如 10 == “10” //false，不会进入循环。例2 也是如此，通过判断 a > 1 === true ？ ，判断进入哪个case

千万要记住一点， 字符不加 “ ”，是变量

例1：

```
	var num = 1;
	switch (num) {
		case 1 :
			alert(1);
			break;
		case 2 :
			alert(2);
			break;
		case 3 :
			alert(3);
			break;
		default:
			alert("other");
	}
	
```

例2：

```
	var a=100;
	switch (true) {
		case a<10:
			alert("a<10");
			break;
		case a>10 && a<20:
			alert("10<a<20");
			break;
		case a>20 && a<30:
			alert("20<a<30");
			break;
		default:
			alert("other");
	}
```



### 第4章 变量、作用域和内存问题

1、对象的实例是引用类型的，在复制时，复制的是一个指针，指向同一个对象。所以对象是按引用传递的

2、

| typeof           | instanceof       |
| ---------------- | ---------------- |
| 检测基本数据类型 | 检测引用数据类型 |

3、try-catch语句中的catch块和with语句会延长作用域链

4、javascript没有块级作用域，if 和 for 语句（可能不止）中声明的变量会添加到当前的执行环境中，(应该说，除了函数的作用域外，其他都没有块级作用域)

	即 for 循环执行结束后，也依然会存在于循环外部的执行环境中

5、你必须充分认识到，在 function fn(a){}的声明中，其实是 在函数内部 var a；所以，如果此时对a进行操作，例如定义 a = {}，也绝不会影响到函数外部的a。

6、函数和作用域。环境中定义的所有的变量和函数都会保存在一个变量对象（variable object）中，当代码在一个环境中执行时，会创建变量对象的一个作用域链，其作用是保证对执行环境的有权访问的所有变量和函数的有序访问；作用域链的前端，始终都是当前执行的代码所在环境的变量对象



### 第5章 引用类型

1、引用类型描述的是一类对象具有的属性和方法，它是对象的原型。

2、创建Object类型的实例有两种方式  

 	1、 new+构造函数： var person = new Object（）

	 2、对象字面量：person = {
	
		1: one，
	
		2:two
	
	      }



3、javascript 的数组每一项都可以保存任何类型的数据

	  创建方式有构造法和字面量法
	
	length是数组的一个属性，而不是方法，所以调用的时候是arr.length
	
	数组的方法 ------栈方法，队列方法，和排序方法是会修改数组本身的

1. 转换方法：

   toLocaleString()：先创建一个以“，""为间隔的字符串，对数组的每一项调用toLocaleString（）

   toString()：返回一个由数组中每一项的字符串形式以”，“为间隔拼接而成的字符串

   valueOf()：返回数组本身

   join（）：接收一个参数，用作分隔符，例如a.join（“|”），变成字符串

2. 栈方法：

   push（）在数组末尾加入数据，并修改数组长度  ，返回值为修改后数组的长度

   pop（）在数组末尾删除数据，返回被删除的项

3. 队列方法：
   shift（）：在数组前端删除，返回被删除的项

   unshift（）：在数组前端添加

4. 重排序方法:  （对数组本身进行修改）
   reverse():将数组倒序

   sort（）：接收参数是一个function（比较函数）【a，b】：a>b return 1(大于0);a=b:return 0.

   对于reverse和sort函数，返回值是排序后的数组，即是对数组本身进行操作（a->拍好序的a）而非数组的复制

   sort对纯数字数组通过自定义函数，可以进行升序和降序

   对纯字母数组可以排序（升序） 但不能自定义

   对混合类型的按照ASCII码升序 不能自定义

5. 操作方法：

   concat（）：数组拼接

   slice（）：切数组，slice（1,4），从下标为1-3，不包括4，

   splice（）：最强大的数组方法，

   concat和slice不对数组本身进行修改，在调用时会创建一个元数组的副本，在对副本进行操作，返回值是副本

   |   操作方法    | 功能 |                 参数                 |                            返回值                            |                  说明                  |
   | :-----------: | :--: | :----------------------------------: | :----------------------------------------------------------: | :------------------------------------: |
   |    concat     | 连接 |            数组或单个的值            |                       修改后的数组副本                       |            原数组没有被修改            |
   |     slice     |  切  |     起始下标和终止下标（可没有）     | 修改后的数组副本，且不包括终止下标的值，而是终止下标的前一个 | 原数组没有被修改，负值则与数组长度相加 |
   | splice(0,2,a) |  切  | （初始下标，要删除的个数，添加的项） |                    `被删除的值组成的数组`                    |              原数组被修改              |

   

6. 位置方法：

   indexOf（）：要查找的项和表示查找起点位置的索引（可选的），从前头往后找

   lastIndexOf（）：从数组的末尾开始往前找

7. 迭代方法：所有方法都不会修改原数组，且接受参数都为一个函数

   every（）

   filter（）

   forEach（）

   map（）

   some（）

   | 迭代方法 |           返回值           |              说明              |
   | :------: | :------------------------: | :----------------------------: |
   |  every   |         true/false         | 每一项都返回true-最终返回true  |
   |   some   |         true/false         | 任意一项返回true->最终返回true |
   |  filter  |       满足条件的数组       |                                |
   |   map    | 返回函数调用结果的组成数组 |                                |
   | forEach  |             无             |         相当于for循环          |

   

8. 归并方法：

   reduce（）

   reduceRight（）



4、Function类型

- 函数名实际上也是一个指向函数对象的指针
- 声明方式
  - 函数声明语法（function关键字）
    function sum（）{}
  - 函数表达式
    var sum = function（）{} 
- 不带圆括号的函数名是访问函数指针，而非调用函数（P110） 
- 函数声明会有代码提升效果，即系统在编译文件时，扫到function关键字，会把function定义函数提升到顶部，所有会有即使是先调用，再声明函数也不会出错，注意函数表达式没有此功能
- 函数内部属性
  - arguments 是一个类数组对象，包含传入参数的所有属性
    - 它有一个 callee 属性，指向拥有 arguments 对象的函数，例如阶乘函数
  - this 引用的是函数执行的环境对象
- 函数的属性
  - length：表示函数希望接受的命名参数的个数
  - **prototype**：         
- 函数的方法（非继承，原生就有的）：
  - apply（）
  - call（）
    这两个方法是设置this的指向，区别在于接受参数的方式不同
  - bind 

  

5、基本包装类型

基本包装类型是指 为了操作基本类型值，ECMAScript提供了3个特殊的引用类型：Boolean，Number和String。因为Boolean，Number和String,这3中基本类型本应该没有方法的，但是为了便于操作，ECMAScript提供了操作他们的方法。例如string的substring方法。

在调用方法时后台完成的步骤：

	1、创建String类型的一个实例（对象）
	
	2、在实例上调用指定方法
	
	3、销毁这个实例

引用类型和基本包装类型的主要区别是对象的生存期 ，使用new操作符创建的引用类型的实例，在执行流离开作用域之前都被一直保存在内存中，而自动创建的基本包装类型，则只存在于一行代码执行的瞬间，然后立刻被销毁。意思是即使你为字符串添加属性和方法，但是在代码执行到下一行，这个属性和方法就被销毁了。所以我们无法为基本包装类型添加属性和方法。

对基本包装类型执行 typeof 的结果为 Object

1. String

   - 字符方法

     |     方法名      |         返回值          | 说明 |
     | :-------------: | :---------------------: | :--: |
     |   charAt（1）   |      下标为1的字符      |      |
     | charCodeAt（1） | 下标为1的字符的字符编码 |      |

   - 字符串操作方法

     |  方法名   |                      参数                      |                        返回值                        |                      说明                      |
     | :-------: | :--------------------------------------------: | :--------------------------------------------------: | :--------------------------------------------: |
     | slice（） |     第一个参数为起始下标，第二个为终止下标     | 返回起始下标到终止下标（不包括终止下标）之间的字符串 |        当参数负，负值与字符串的长度相加        |
     | substring |     第一个参数为起始下标，第二个为终止下标     | 返回起始下标到终止下标（不包括终止下标）之间的字符串 |             当参数为负，负参数为0              |
     |  substr   | 第一个参数为起始下标，第二个为返回字符串的长度 |        从起始下标开始长度为第二个参数的字符串        | 将负的第一个参数+字符串长度，负的第二个参数为0 |

   - 字符串位置方法

     |   方法名    |                     参数                     |       返回值       |    说明    |
     | :---------: | :------------------------------------------: | :----------------: | :--------: |
     |   indexOf   | 第一个为要查找的字符，第二个为开始查找的位置 | 返回查找元素的下标 | 从前往后找 |
     | lastIndexOf | 第一个为要查找的字符，第二个为开始查找的位置 | 返回查找元素的下标 |  从往前找  |

   - trim（）

     创建字符串的副本，删除字符串的所有前置及后缀的所有空格

   - 字符串大小写转换

     |   方法名    | 参数 |       返回值       |             说明             |
     | :---------: | :--: | :----------------: | :--------------------------: |
     | toLowerCase |  无  | 转换后字符串的副本 | 原字符串不变,将字符串变小写  |
     | toUpperCase |  无  | 转换后字符串的副本 | 原字符串不变，将字符串变大写 |

   - 字符串模式匹配

     |   字符串    |  参数  | 返回值 |                             说明                             |
     | :---------: | :----: | :----: | :----------------------------------------------------------: |
     | split("\|") | 分隔符 |  数组  | 以分隔符为间隔，分割字符，形成数组，split("")则代表着没有分隔符，把每一个字符单独切割  'abc' => ['a','b','c']；split(" ")则是以空格为分隔符，这两者是不一样的 |
     |             |        |        |                                                              |
     |             |        |        |                                                              |
     |             |        |        |                                                              |

     

2. Number

3. Boolean    

     

### 第6章 面对对象的程序设计

每个对象基于一个引用类型创建的，引用类型的实例化 --> 对象，引用类型与基本类型的区别在于其具有方法和属性，也就是对象就有方法和属性。

每个属性都有两大特性：数据属性和访问器属性



### 第7章 函数表达式

1、只想搞清楚一点：闭包和普通函数，还有this的进一步加深理解

	闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见方式，就是在一个函数内部创建另外	 一个函数，然后将这个函数作为返回值

例1：

```
	var name = 'window';
	var object = {
		name: 'object',

		getName:function(){
			console.log(this)
			var that = this
			return function(){       
			//这就是闭包，函数内部返回一个函数，获取外部（object）的变量，因为正常来说，当环境执行到其			 //	他作用域时，这个变量就会被销毁，或者说，外部作用域，无法获得内部作用域的变量，这时就需				//	要闭包
				return this.name;    
			}
		}
	}
	console.log(object.getName());   //结果是什么？？？？
	//是一个函数，function（）{return this.name}
	console.log(object.getName()())  //注意多了一个括号 ，结果是什么
	//是window！！！没想到吧？？为什么呢？ 
	//其实也很好理解，obj.getName（）是一个匿名函数，匿名函数中this的指向是当前的执行环境，即是谁调用就	   //指向谁，在window下调用的，就是指向window.name ，所以输出是window
```

例2：

```
	var name = 'window';
	var object = {
		name: 'object',
		getName:function(){
				return this.name;   //这里是直接返回一个值，不是闭包，这也是我想跟你说的，区别 
		}
	}
	console.log(object.getName());   //结果是 object
```



这就是我想跟你说的最大区别。

1、函数返回值是一个函数和函数返回值是一个值得区别。当一个函数加上()，也就意味是执行了这个函数，执行的结果，是将返回值输出，如果 有 值接受，意思是   a = object.getName()，此时 a =  object.getName()的返回值。如果，返回值是一个函数，那么 a 就是一个函数(并没有执行)，这也是 console.log(object.getName()()) 的原因。当 返回值是一个值，那么 a 就是一个值。

2、this 的指向：谁调用就指向谁。但是当函数的返回值是一个匿名函数时，匿名函数的执行环境具有全局性，因此其this指向window



### 第8章 BOM

1、全局变量不能通过 delete 操作符删除，而直接在 window 上定义的属性可以



### 第10章 DOM 

1. Node类型
   每个节点都有nodeType属性，用于表明节点的类型，element是1，text是3，document是9

   - 节点关系

     |      方法       |           使用           |       返回值       |                  说明                  |
     | :-------------: | :----------------------: | :----------------: | :------------------------------------: |
     |   childNodes    |   someNode.childNodes    |     是一个数组     | 属于父元素的方法，文本也算是一个子节点 |
     |   firsrChild    |   someNode.firstChild    |  返回第一个子节点  |               属于父元素               |
     |    lastChild    |    someNode.lastChild    | 返回最后一个子节点 |               属于父元素               |
     |   parentNode    |   someNode.parentNode    |     返回父元素     |               属于子元素               |
     | previousSibling | someNode.previousSibling | 返回上一个兄弟节点 |               属于子元素               |
     |   nextSibling   |   someNode.nextSibling   | 返回下一个兄弟节点 |               属于子元素               |

   - 操作节点----都是父节点对子节点的操作方法，所以要想像是下面四种方法，要先取得父节点元素

     |      方法      |                     使用                      |    返回值    |                     说明                     |
     | :------------: | :-------------------------------------------: | :----------: | :------------------------------------------: |
     | appendChild()  |         someNode.appendChild(新节点)          |  新增的节点  | 一般配合创建节点使用，实在最后一个子节点加入 |
     | insertBefore() | someNode.insertBefore(新加入的节点，参考节点) | 新加入的节点 |   如果参考节点为null，则在最后一个节点插入   |
     |   removeNode   |             someNode.removeNode()             | 被移除的节点 |                                              |
     |  replaceNode   |             someNode.replaceNode              |   替代节点   |                                              |

2. Document 类型

   document对象时window对象的一个属性

   各种查找元素的方法，例如document.getElementById

   创建元素的方法 document.createElement

3. Element 类型

   - HTML元素的属性

     id，title，lang，dir

     className 

     |     方法     |          使用          |    返回值    |
     | :----------: | :--------------------: | :----------: |
     | getAttribute | div.getAttribute("id") | 返回元素的id |
     | setAttribute |        两个参数        | 新加入的节点 |
     | replaceNode  |  someNode.replaceNode  |   替代节点   |