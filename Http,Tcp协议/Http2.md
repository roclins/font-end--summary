### HTTP0.9

- 只有GET方法
- 只能传输HTML文件
- 服务端发送完数据之后，TCP断开连接

### HTTP1.0

- 有GET、POST、HEAD方法
- 新增了传输的文件格式，例如二进制文件、图片、视频等
- 增加了头部信息
- 新增了状态码、缓存、多字符集支持

#### 缺点

不能持久连接，请求响应之后，TCP断开连接，下一个请求还是要重新3次握手，浪费资源，虽然引入了Connection：Keep-alive，但是这是不规范的

### HTTP1.1

- 最大的变化是引入了持久连接：也就是HTTP请求完成后，TCP不断开连接，可以继续发送下一个请求。浏览器默认最大可以接受6-8个持久连接

- 管道机制：在同一个TCP连接中，客户端可以发送多个HTTP请求。举个例子：有两个请求A，B

  - HTTP1.0的版本中，一个TCP连接中只能发送一个请求，响应完毕后就断开；B请求要重新连接，再发送
  - HTTP1.1中：一次TCP连接发一次HTTP请求A，，可以不等待客户端的响应，可以回来继续发B请求。

  持久连接+管道机制：可以将想象为一个TCP连接中有6个管道，每个管道都可以发一个HTTP请求。

- Content-Length：用来区分数据包是哪一个请求的响应

- 分块传输编码：

#### 缺点

队头阻塞：虽然客户端可以发送多个HTTP，但服务端只能按顺序一个一个去处理，要是前面的请求处理特别慢，就会造成队头阻塞

### HTTP2

#### 二进制协议

**帧：**HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。

HTTP1.0版本中，头为文本信息，体是可以是文本，也可以是二进制。但在HTT2中，头和体成为了彻头彻尾的二进制，并且统称为帧。

#### 多工

在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。 

举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。 

- **同个域名只需要占用一个 TCP 连接**，消除了因多个 TCP 连接而带来的延时和内存消耗。

#### 数据流

**流：**存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。 

因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号（`RST_STREAM`帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

- 单个连接上可以并行交错的请求和响应，之间互不干扰。
- 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。